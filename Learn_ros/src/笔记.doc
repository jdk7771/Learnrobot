cpp:
     å¿…é¡»æŒæ¡çš„C++æ ¸å¿ƒæ¦‚å¿µ
1. ç°ä»£C++ç‰¹æ€§ï¼ˆC++11/14/17ï¼‰
cpp

// æ™ºèƒ½æŒ‡é’ˆï¼ˆå¿…é¡»æŒæ¡ï¼‰
std::unique_ptr<Navigation> nav = std::make_unique<Navigation>();
std::shared_ptr<Sensor> sensor = std::make_shared<Camera>();

// ç§»åŠ¨è¯­ä¹‰
RobotState state = std::move(new_state);

// Lambdaè¡¨è¾¾å¼
auto callback = [this](const Pose& pose) {
    this->updatePose(pose);
};

// è‡ªåŠ¨ç±»å‹æ¨å¯¼
auto config = loadConfig();  // ä»£æ›¿ Config config = loadConfig();

2. é¢å‘å¯¹è±¡è®¾è®¡æ¨¡å¼
cpp

// å·¥å‚æ¨¡å¼ - Galbotä¸­å¸¸è§
class RobotFactory {
public:
    static std::unique_ptr<Robot> createRobot(RobotType type);
};

// ç­–ç•¥æ¨¡å¼ - è¿åŠ¨è§„åˆ’ä¸­ä½¿ç”¨
class MotionStrategy {
public:
    virtual bool planPath(const Pose& start, const Pose& goal) = 0;
};

3. æ¨¡æ¿ç¼–ç¨‹
cpp

// åŸºç¡€æ¨¡æ¿ - é…ç½®è§£æä¸­å¸¸è§
template<typename T>
T ConfigParser::get(const std::string& key);

// æ ‡å‡†åº“å®¹å™¨ä½¿ç”¨
std::unordered_map<std::string, std::vector<double>> config_map;

ğŸ“š Galboté¡¹ç›®ç‰¹åˆ«éœ€è¦çš„çŸ¥è¯†ç‚¹
1. å¤šçº¿ç¨‹ç¼–ç¨‹
cpp

// çº¿ç¨‹å®‰å…¨çš„æ•°æ®è®¿é—®
std::mutex pose_mutex;
std::condition_variable data_ready;

// å¼‚æ­¥ä»»åŠ¡ - æ„ŸçŸ¥æ¨¡å—å¸¸ç”¨
auto future = std::async(std::launch::async, &Perception::processImage, this, image);

2. èµ„æºç®¡ç†
cpp

// RAIIæ¨¡å¼ - æ–‡ä»¶ã€ç½‘ç»œè¿æ¥ç®¡ç†
class FileHandler {
private:
    std::unique_ptr<std::ifstream> file_;
public:
    ~FileHandler() { if(file_) file_->close(); }
};

3. é”™è¯¯å¤„ç†
cpp

// å¼‚å¸¸å®‰å…¨ä»£ç 
bool tryMoveTo(const Pose& target) {
    try {
        return motion_planner_->plan(target);
    } catch (const std::exception& e) {
        LOG(ERROR) << "Motion planning failed: " << e.what();
        return false;
    }
}

ğŸ”§ å®è·µç»ƒä¹ å»ºè®®